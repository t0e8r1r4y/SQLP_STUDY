# 라이브러리 캐시 최적화 원리
> 해당 챕터는 `친절한 SQL`의 내용 중 [SQL 옵티마이저와 SQL 처리 과정](https://github.com/t0e8r1r4y/SQLP_STUDY/wiki/SQL-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80-&-SQL-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95%EA%B3%BC-I-O#7%EC%9E%A5-sql-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80)에 대해 정리한 내용을 함께 참고하면 됩니다.

<br>


## 1️⃣ SQL과 옵티마이저
- `옵티마이저`는 최적화를 담당하는 프로세스다.
- 사용자가 입력한 SQL을 옵티마이저가 해석하고 최적화된 실행계획을 프로시저한테 넘겨주는 역할을 한다.
- SQL 옵티마이저는 최소비용, 최적의 경로를 선택해서 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 프로시저를 자동으로 생성해주는 DBMS의 가장 핵심이다.

<br>


## 2️⃣ SQL 처리 과정
- 가장 기본 프로세스는 아래와 같다.  
<img width="515" alt="스크린샷 2022-11-04 오후 12 36 55" src="https://user-images.githubusercontent.com/91730236/199880026-e0a892f0-60ee-43bc-a1b1-8adfeddbdfc3.png">

- 각 단계별 상세 내용은 아래와 같다.

#### SQL 파싱
- SQL Parser : 사용자가 던진 SQL을 가장 먼저 받아서 처리하는 End Point 엔진이다.
- 순서 : 개별 구성요소 분석 -> 파싱 트리 생성 -> 문법 체크(Syntax check) -> 문맥 체크(Semantic check) -> 캐싱 여부 확인 -> cache hit fail 시  SQL 커서 생성 ( 성공시 다음 실행단계 이동)

> SQL 커서란?  
> 커서는 하드 파싱 과정을 거쳐 메모리에 적재된 SQL과 Parse Tree, 실행계획, 그리고 그것을 실행하는데 필요한 정보를 담은 SQL Area를 말한다.  
> 뒤에 더 상세히 다룬다고는 하는데, 요정도 알고 읽어야 읽히더라.


#### SQL 최적화
- Core 엔진. 시스템 통계 및 오브젝트 통계정보를 판단기준으로 삼아 다양한 액세스 경로를 비교하고 그 중 가장 효율적인 실행 계획을 선택
- 아래 3가지 쿼리엔진을 사용한다.
  - Query Transformer
  - Plan Generator
  - Estimator
- 최적화 과정에 대한 정리는 책 후반부에서 좀 더 상세하게 다뤄질 예정
- 간략한 요약은 [링크](https://github.com/t0e8r1r4y/SQLP_STUDY/wiki/SQL-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80-&-SQL-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95%EA%B3%BC-I-O#7%EC%9E%A5-sql-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80) 참고

#### Row-Source Generation
- 옵티마이저가 만들어낸 실행 계획을 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 작업을 하는 프로세서


<br>


## 3️⃣ 라이브러리 캐시 구조

#### 🏗️ 전반적인 구조  

- 라이브러리 캐시는 Shared Pool 내에 위치하고 있다. ( 여기쯤 왔다면 분명 Oracle Architecture에서 기억이 안날법도 하기에 해당 내용에 대해 [링크](https://github.com/kmw8551/study/blob/main/oraclearch/chapter/20220925_1%EC%9E%A5.md)를 건다. )  
![192124730-2667fd0d-7ca7-49cc-a82f-f2ccbb67ca51](https://user-images.githubusercontent.com/91730236/199882368-6f274d3f-96d5-49f5-9378-a9ab205fa696.png)  


#### ℹ️ 저장되는 정보
- SQL 공유 커서 및 데이터베이스 오브젝트(테이블, 인덱스 등)에 대한 정보를 관리한다. 그 외 컴파일을 거친  프로시저, 함수, 패키지, 트리거 등 PL/SQL 프로그램을 담는 PL/SQL Area도 라이브러리 캐시에 저장한다.
- 저장되는 정보의 단위를 `라이브러리 캐시 오브젝트` LCO라고 부른다.
  - `실행가능 LCO` : 실행이 가능한 오브젝트 내용들
  - `오브젝트 LCO` : 실행가능 오브젝트뿐 아니라 거기서 참조하는 테이블, 인덱스, 클러스터 같은 데이터베이스 오브젝트 정보들
- 스키마 오브젝트 정보는 데이터 딕셔너리 캐시에도 저장이 되어있지만 `LCO간 의존성 관리 목적`으로 라이브러리 캐시에도 저장한다.
- 저장 기간으로는 아래 2가지로 구분이 가능하다.
  - 영구적으로 보관되는 오브젝트 : 테이블, 인덱스, 클러스터, 뷰, 트리거, 패키지, 사용자 정의 함수/프로시저 등
  - 인스턴스가 떠있는 동안에만 존재하는 오브젝트 : 커서와 Anonymous PL/SQL문

#### 🎛️ 정보가 관리되는 구조
- Shared Pool도 DB 버퍼 캐시처럼 LRU 알고리즘에 의해 관리가 됨.  [링크](https://github.com/kmw8551/study/blob/main/oraclearch/chapter/20220925_1%EC%9E%A5.md)
- Shared Pool 래치를 사용하여 특정 오브젝트 정보 또는 SQL 커서를 위한 Free Chunk를 할당 받으려 할 때 shared pool 래치를 사용한다.
- 라이브러리 캐시도 DB 버커 캐시처럼 해시구조로 관리된다.
<img width="515" alt="스크린샷 2022-11-04 오후 12 36 55" src="https://user-images.githubusercontent.com/91730236/199883470-f28abd72-a146-4b6f-82dd-59264a6a0663.png">  
- 해시 구조로 관리되는 방식은 1장의 설명과 유사하다.
- 아래 성능 이슈가 발생할 수 있는 부분
  - shared pool 래치와 library cache 래치 경합은 소프트/하드 파싱을 동시에 심하게 일으킬 때 발생한다.
  - library cache lock과 library cache pin 대기이벤트는 주로 SQL 수행 도중 DDL을 날릴 때 발생한다.
  - 트랜잭션이 활발한 시간대에 DDL문을 날려 데이터베이스의 오브젝트 정의를 변경하면 라이브러리 캐시에 심한 부하가 발생한다.

#### ✅ 중요한 점
- 커서를 공유할 수 있는 형태로 SQL을 작성한다. -> 바인드 변수를 사용
- 세션 커서 캐싱 기능을 이용해 라이브러리 캐시에서 SQL 찾는 비용을 줄인다.
- 애플리케이션 커서 캐싱을 이용해 Parse Call 발생량을 줄인다.



<br>


## 4️⃣ 커서 공유

#### 커서란?
- 3종류다. `공유 커서`, `세션 커서`, `애플리케이션 커서`. 이것저것 다 커서라고 명명해서 굉장히 개념이 복잡다.
<img width="508" alt="스크린샷 2022-11-04 오후 1 22 42" src="https://user-images.githubusercontent.com/91730236/199886978-499d3e25-2a16-4bc8-a187-02af44c10232.png">
  - 공유 커서 : 라이브러리 캐시에 공유되어 있는 Shared SQL Area. 인스턴스화 되지 않은 상태의 커서라고 보면된다. 다른 프로세스간 공유가 가능한 상태이다.  
  - 세션 커서  : Private SQL Area에 저장된 커서. PGA 영역에서 인스턴스화 한 커서를 지칭한다.  
  - 애플리케이션 커서 : 세션 커서를 가리키는 핸들. PGA에 있는 커서의 핸들러다. 오라클에서 관리하는 객체가 아니라 애플리케이션에서 생성한 객체이다.  

#### 커서 공유
- 라이브러리 캐시의 공유 커서를 말한다. 여러 세션에 의해 공유되면서 반복 재사용된다.
- 해당 커서는 오브젝트에 컬럼이 추가/삭제 되거나 새로운 인덱스가 만들어지거나 오브젝트 통계를 새로 수집하는 등의 DDL문이 수행되는 경우 무효가 된다.
- 커서를 공유하려면 식별하는 키가 필요한데 SQL문 자체가 Key다.

> 여기서부터 스캔을 잘못떳는지... 몇 페이지가 소실되었다. 바인드 변수까지 내용이 읍따.

<br>


## 5️⃣ 바인드 변수의 중요성 🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟

#### 바인드 변수란
- `:변수명` 형태로 사용하는 변수
- Hard Parsing을 줄이기 위한 목적
- 오라클의 경우 캐시를 조회할 때 SQL을 key값으로 사용하는데 바인드 변수를 사용하지 않으면, 모든 SQL문이 다른 SQL로 인식하기 때문에 불필요한 Hard Parsing이 증가한다. 이때 바인드 변수를 쓰면 변수의 값이 달라져도 동일한 SQL문으로 인지하기에 불필요한 Hard Parsing을 줄이는 효과를  가져온다.
- 즉 커서를 계속 생성하지 않고, 하나를 반복 재사용하므로서 메모리 사용량과 파싱 소요 시간을 획기적으로 줄여준다. -> 이 말인 즉슨 컴퓨팅 파워를 적게 쓴다는 이야기가 된다.

#### 성능 개선 예시
- 요건 음... 한번 책의 예시가 아닌 적절한 예시를 찾아 올리겠다.

#### ⚠️ 사용시 주의사항
- 다음 6번에서 언급하는 내용을 잘 지키지 않으면 반대로 라이브러리 캐시 경합 때문에 시스템 정상 가동이 어려울 수 있다.

<br>


## 6️⃣ 바인드 변수의 부작용과 해법
#### 💥 부작용
  - 바인드 변수를 사용하면 컬럼 히스토그램을 제대로 활용하지 못한다. 즉 [커디널리티 곱](https://github.com/t0e8r1r4y/SQLP_STUDY/wiki/SQL-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80-&-SQL-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95%EA%B3%BC-I-O#71-%ED%86%B5%EA%B3%84%EC%A0%95%EB%B3%B4%EC%99%80-%EB%B9%84%EC%9A%A9-%EA%B3%84%EC%82%B0-%EC%9B%90%EB%A6%AC)으로 비용을 계산때려버린다.
  - 파티션 테이블을 쿼리할 때 파티션 레벨 통계 정보를 이용하지 못하게 된다. 부정확한 테이블 레벨 통계를 적용한다.


#### 🔜 해결책
- 바인드 변수 Peeking
- 적응적 커서 공유
- 입력 값에 따라 SQL 분리
- 예외적으로, Literal 상수값 사용

<br>


## 7️⃣ 세션 커서 캐싱
> 자주 수행하는 SQL에 대한 세션 커서를 `세션 커서 캐시`에 저장할 수 있는 기능

- 캐시를 사용하는 것도 굉장히 비용이 많이 드는 작업이다. 공유 캐시를 세션캐시로 인스턴스화 하는 비용, 해제에 따른 비용, 캐시를 탐색하는 비용 등이 발생하는데 이것을 줄이고자 하는 것이 목적이다.
- `세션 커서 캐싱`을 활성화하면, 커서를 닫는 순간 해당 커서의 Parse Call 횟수를 확인해 보고 그 값이 3보다 크거나 같으면 세션 커서를 세션 커서 캐시로 옮기고, 공유 커서를 가리키는 포인터도 저장한다.
- 이를 통해 커서는 닫힌 상태지만 세션 커서 캐시에 저장된 정보를 활용하여 더 빠르게 실행을 하는 것이다.

<br>


## 8️⃣ 애플리케이션 커서 캐싱
> 세션 커서 캐싱도 생략하고 빠르게 SQL을 실행하고 싶으다 -> 애플리케이션 커서 캐싱을 한다.

- 애플리케이션 커서 캐싱이란 공유 커서를 Pin(고정)한채 반복 수행하는 방식. 단 동시에 열어놓을 수 있는 커서 개수가 PGA 용량과 서버 파라미터에 의해 제한되므로 무작정 쓸 수는 없다.
- Parse Call이 최초 한번만 일어나고 이후로는 발생하지 않기 때문에 성능 개선 효과를 가져올 수 있음
- 커서 개념 정리에서 애플리케이션 커서는 오라클이 아닌 애플리케이션에서 생성하는 것이기 때문에, 언어마다 구현 방식의 차이가 생긴다고 저자가 언급함.


#### JAVA를 사용한 예시


<br>


## 9️⃣ Static  vs Dynamic SQL

> 필자가 하고싶은 이야기는 결국 바인드 변수의 사용여부를 가지고 static과 dynamic을 구분하지 말자다.  


#### Static SQL
- String 형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문을 말한다. ( = Embedded SQL )
- PreCompiler가 ProCompile 과정에서 static SQL을 발견하면 이를 SQL 런타임 라이브러리에 포함된 함수를 호출하는 코드로 변환한다.
- 이 과정에서 결국 String형 변수에 담긴다.
- PreCompile 단계에서 구문 분석, 유효 오브젝트 여부, 오브젝트 엑세스 권한 등을 체크하는 것이 가능


#### Dynamic SQL
- String 형 변수에 담아서 기술하는 SQL
- String 변수를 사용함으로 조건에 따라 SQL문을 동적으로 바꿀 수 있고, 런타임 시에 사용자로 부터 SQL문의 일부 또는 전부를 입력받아서 실행이 가능함.
- PreCompiler는 Dynamic SQL을 만나면 그대로 통과 시킨다. syntax 체크가 안된다.

#### 문제의 본질은 바인드 변수 사용 여부
- static, dynamic 모두 DB 입장에서는 차이가 없다. (String 형태의 SQL을 받기 때문에~~~)
- 성능 이슈는 바인드 변수를 사용하지 않았을 때 발생한다는 것!

<br>


## 🔟 Dynamic SQL 사용 기준

> 기본원칙은 Static SQL로 작성하는 것이며, 방법이 없거나 SQL이 너무 복잡할 때만 Dynamic SQL을 꺼내 들려고 노력하라.   



#### 기본원칙
1. Static SQL을 지원하는 개발환경이면 Static SQL로 작성하는 것을 원칙으로 한다.
    - Static SQL은 PreCompile 과정을 거치므로 런타임 시 안정적인 프로그램 Build가 가능하다는 장점이 있다.
    - Dynamic SQL을 사용하면 애플리케이션 커서 캐싱 기능이 작동하지 않는 경우가 있는데, 이 기능이 필요한 상황에서 Dynamic SQL을 사용하면 성능이 나빠진다.  
2. 아래 경우는 Dynamic SQL을 사용해도 무방하다.
    - PreCompile 과정에서 컴파일 에러가 나는 구문을 사용할 때, 예를 들어 Proc*C에서 스칼라 서브쿼리, 분석함수, ANSI 조인 등
    - 상황과 조건에 따라 생성될 수 있는 SQL 최대 개수가 많아 Static SQL로 일일이 나눠서 작성하려면 개발 생산성이 저하되고 유지보수 비용이 매우 커질 때  
3. 2번의 경우에 해당해서 Dynamic SQL을 사용하더라도 조건절에는 반드시 `바인드 변수` 사용을 원칙으로 한다. 특히 사용빈도가 높고 조건절 컬럼의 값 종류가 매우 많을 때는 반드시 준수한다.
4. 3번 바인드 변수 사용원칙을 준수하되 아래 경우는 예외적으로 인정한다.
    - 배치 프로그램이나 DW, OLAP 등 정보계 시스템에서 사용되는 Long Running 쿼리. 이들 쿼리는 파싱 소요시간이 쿼리 총 소요시간에서 차지하는 비중이 매우 낮고, 수행빈도가 낮아 하드파싱에 의한 라이브러리 캐시 부하를 유발할 가능성이 적음
    - OLTP성 애플리케이션이더라도 사용빈도가 매우 낮아 하드파싱에 의한 라이브러리 캐시 부하를 유발할 가능성이 없을 때, 예외적으로 인정하는 것이므로 단순히 바인드 변수 정의하는 게 귀찮다고 그렇게 해서는 안됨
    - 조건절 컬럼의 값 종류가 소수일 때, 특히 값 분포가 균일하지 않아 옵티마이저가 컬럼 히스토그램 정보를 활용하도록 유도하고자 할 때


<br>


## 🔟+1️⃣ Static SQL 구현을 위한 기법들


<br>
