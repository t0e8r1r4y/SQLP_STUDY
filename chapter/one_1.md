# 오라클성능고도화

# 1. 오라클 성능 고도화 원리와 해법

     요약
     - 래치란? : sga 내 다양한 자료구조를 보호하기 위해 구현된 일종의 가벼운 Lock 매커니즘 ( 인스턴스 범주는 래치, Lock은 전체 범위 )
     - Block : 오라클에서 사용되는 가장 작은(기본 단위) 논리적, 물리적  데이터의 집합
     - Block단위 I/O : 오라클 데이터베이스 구분을 (가장 큰 단위 순서로) 테이블 스페이스, 세그먼트, 인스텐트, 블록으로 구분을 하는데 I/O는 가장 작은 단위인 블록을 기준으로 수행한다.
     - SGA란 : 각각의 서버 프로세스 및 백그라운드 프로세스로부터 받은 요청을 효과적으로 처리하기 위한 공유 메모리 영역
     - SGA 사용 목적 : disk read/write 효율성 획득 ( 일종의 캐시 역할 )




## 1-1. 오라클 아키텍처

### 1-1-1. 기본 아키텍처

![%E1%84%8B%E1%85%A9%E1%84%85%E1%85%A1%E1%84%8F%E1%85%B3%E1%86%AF_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3 drawio](https://user-images.githubusercontent.com/91730236/192124701-36bb7d94-fe43-44c1-a4cb-9ad6d7615518.png)

1. 데이터베이스 : 디스크에 저장 된 데이터 집합
2. 인스턴스 : SGA 공유 메모리 영역과 이를 엑세스하는 프로세스
    
    [Process Architecture](https://docs.oracle.com/cd/B19306_01/server.102/b14220/process.htm)
    
3. Connection Pool
    1. 클라이언트가 오라클에 접속을 할 때 하나의 프로세스가 fork되고  PGA가 할당 됨.
    2. PGA를 할당하는 것은 비용이 큰 작업이기에, 미리 사용이 가능한 pool을 생성하고 요청에 대한 반응성을 높임
4. RAC(Real Application Cluster) 환경
    1. 하나의 데이터베이스를 액세스하는 다중 인스턴스 구성
    2. 공유 캐시 방식을 지원함
    3. 인스턴스간 데이터 블록을 동기화 하여 데이터 처리가 가능 ( ping) 이라고 함.

### 1-1-2. DB 버퍼 캐시

![Untitled](https://user-images.githubusercontent.com/91730236/192124730-2667fd0d-7ca7-49cc-a82f-f2ccbb67ca51.png)

<aside>
💡 빠른 데이터 입출력을 위해서 Database Buffer Cache를 이용해서 데이터를 재사용 한다.

</aside>

1. **블록 단위 I/O**
    1. 오라클에서 I/O의 단위는 Block이다.
    2. Single Block I/O와 Multi Blcok I/O
        1. Single Block I/O : 블록을 한 블록씩 읽는다.
            1. 데이터 파일에서 버퍼 캐시로 블록을 적재할 때
            2. 인덱스를 경유한 테이블 액세스 시
        2. Multi Block I/O : 블록을 여러 블록씩 한번에 읽는다.
            1. Full Scan 시 사용
            2. DBWR 프로세스는 버퍼 캐시로부터 변경된 블록을 주기적으로 데이터 파일에 기록 할 때
    3. 성능과 관련하여 읽어들이는 블록의 개수가 큰 영향을 끼친다.
2. **버퍼 캐시 구조**
    1. 해시 테이블 구조로 관리 됨.
        
        ![%E1%84%87%E1%85%A5%E1%84%91%E1%85%A5_%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5_%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9 drawio](https://user-images.githubusercontent.com/91730236/192124737-b71bad7d-a91f-4aeb-9b1b-9a1e16728a7c.png)
        
    2. 해시의 키 값은 DBA(데이터 블록 주소)로 관리함.
3. **캐시 버퍼 체인**
    1. 각각의 해시 체인은 래치(Latch)에 의해 보호 됨. → 동시 접근에 대한 이슈를 해결하기 위한 Lock 매커니즘 → 래치는 데이터 자체를 보호하는 것은 아니고 **SGA에 공유되어 있는 자료구조를 보호하는 것이 목적임**
    2. 하나의 래치가 여러 해시 체인을 동시에 관리하기도 함.
    3. 위 이미지에서 표시한 붉은색 해시 체인 처럼 **하나의 해시 체인에 하나의 버퍼만 달리는 것을 목표함**
4. **캐시 버퍼 LRU 체인**
    1. 버퍼 캐시가 사용빈도가 높은 데이터 블록들 위주로 구성될 수 있도록 LRU(Least Recently Used) 알고리즘을 사용해서 관리함.
    2. LRU 리스트에는 내부적으로 두개의 리스트를 지님
        1. Dirty List : 캐시 내에서 변경되었지만, 아직 디스크에 기록되지 않은 Dirty 버퍼블록을 과리하며, LRUW 리스트라고도 함
        2. LRU 리스트 : 아직 Dirty 리스트로 옮겨지지 않은 나머지 버퍼 블록들을 관리한다.
    3. LRU 리스트를 보호하기 위해 사용하는 래치를 cache buffer lru chain 래치라고 함.
5. 캐시 버퍼의 상태
    1. 모든 캐시는 아래 세 가지 중 하나의 상태에 높인다.
        1. Free 버퍼 
            1. 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어 있는 상태
            2. 데이터가 담겨있지만 데이터파일과 서로 동기화되어 있는 상태여서 언제든지 덮어 써도 무방한 버퍼 블록
            3. 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 함
            4. Free 버퍼 변경이 발생하면 그 순간 Dirty 버퍼로 상태가 바뀐다.
        2. Dirty 버퍼
            1. 버퍼에 캐시된 이후 변경이 발생했지만, 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 버퍼 블록을 말함
            2. 이 버퍼 블록들이 다른 데이터 블록을 위해 재사용되려면 디스크에 먼저 기록되어야 함.
            3. 디스크에 기록되는 순간 Free 버퍼로 상태가 변함
        3. Pinned 버퍼
            1. 읽기 또는 쓰기 작업을 위해 현재 액세스 되고 있는 버퍼 블록을 말함
